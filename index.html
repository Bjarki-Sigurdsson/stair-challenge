<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Stair Climb Challenge! üßó‚Äç‚ôÄÔ∏è</title>
    <!-- Use the Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include Google Font 'Inter' for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /*
         * Main CSS for the background.
         * We apply these styles to the 'body' element to ensure the background covers the entire page.
         */
        body {
            font-family: 'Inter', sans-serif;
        }

        .mountain-bg {
            /* Set the background image to a high-quality mountain range. */
            background-image: url('https://images.unsplash.com/photo-1549880338-65ddcdfd017b?q=80&w=2938&auto=format&fit=crop&ixlib=rb-4.0.3');
            
            /*
             * background-size: 'cover' scales the image to be as large as possible
             * so that the background area is completely covered by the image.
             * Some parts of the image may not be in view.
             */
            background-size: cover;
            
            /*
             * background-position: 'center' centers the image horizontally and vertically.
             */
            background-position: center;
            
            /*
             * background-repeat: 'no-repeat' prevents the image from tiling (repeating).
             */
            background-repeat: no-repeat;
            
            /*
             * background-attachment: 'fixed' keeps the background image in the same
             * position relative to the viewport. This creates a cool parallax-like
             * effect when the user scrolls.
             */
            background-attachment: fixed;
            
            /*
             * Set the minimum height of the body to 100% of the viewport height.
             * This is important to ensure the background covers the entire screen,
             * even if the content is short.
             */
            min-height: 100vh;
        }
        
        .podium-1 { border-color: #FFD700; } /* Gold */
        .podium-2 { border-color: #C0C0C0; } /* Silver */
        .podium-3 { border-color: #CD7F32; } /* Bronze */

        /* CSS for the streak icon, making it an absolute position within the card */
        .streak-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
        }
    </style>
</head>
<body class="mountain-bg flex items-center justify-center p-4">

    <!-- 
        This is a new container for all the app's content. 
        It has a semi-transparent dark background to improve readability of the text
        against the bright mountain image. We also use a backdrop-filter to blur the background slightly.
    -->
    <div class="bg-black bg-opacity-10 p-4 md:p-8 rounded-2xl shadow-2xl max-w-4xl text-center backdrop-blur-sm w-full mx-auto my-auto relative z-10">

        <header class="text-center mb-8 relative">
            <!-- Increased heading size to make it more prominent -->
            <h1 class="text-4xl md:text-5xl lg:text-7xl font-bold text-white">Stair Climb Challenge!</h1>
            <p class="text-gray-200 text-lg mt-2">Who will reach the summit before the Christmas party? üéÑ</p>
            <button id="reset-btn" class="absolute top-0 right-0 bg-red-500 text-white text-xs font-bold py-1 px-3 rounded-full hover:bg-red-600">Reset Competition</button>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Overall Leaderboard Section -->
            <section id="leaderboard-overall" class="bg-white p-6 rounded-3xl shadow-lg">
                <h2 class="text-1xl font-bold mb-4 text-center">Overall Leaderboard üèÜ</h2>
                <!-- Changed space-y-3 to space-y-2 for smaller spacing -->
                <div id="leaderboard-list-overall" class="space-y-1">
                    <div class="text-center text-slate-500">Loading scores...</div>
                </div>
            </section>

            <!-- Weekly Leaderboard Section -->
            <section id="leaderboard-weekly" class="bg-white p-6 rounded-3xl shadow-lg">
                <h2 class="text-1xl font-bold mb-4 text-center">This Week's Leaders üóìÔ∏è</h2>
                <!-- Changed space-y-3 to space-y-2 for smaller spacing -->
                <div id="leaderboard-list-weekly" class="space-y-1">
                    <div class="text-center text-slate-500">Loading scores...</div>
                </div>
            </section>
        </div>

        <!-- Participants Section -->
        <section id="participants" class="mt-8">
            <h2 class="text-2xl font-bold mb-4 text-center text-white">Log Your Climb üëü</h2>
            <div id="participant-cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Participant cards will be injected here by JavaScript -->
            </div>
        </section>
        
        <!-- User ID display -->
        <div id="user-info" class="text-center mt-8 text-xs text-slate-400"></div>
    </div>

    <!-- Firebase and App Logic -->
    <script type="module">
        // IMPORTANT: Firebase imports. Do not change these.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, runTransaction, setDoc, serverTimestamp, addDoc, query, orderBy, limit, getDocs, getDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- ‚úèÔ∏è EDIT THIS SECTION ---
        // Add the names of all participants here.
        const participants = ["Anders L", "Anders S", "Annett", "Bjarki", "Eivind", "Erik √ò", "Erik T", "Felipe", "Flora", "Fredrik A", "Fredrik D", "Frode H", "Frode V", "Halvard", "Henok", "Kristin", "Lars", "Lene", "Love", "Magnus", "M√•ns", "Marcin", "Marcus", "Maria", "Martin", "Michal", "Morten", "Mostafa", "Niklas", "Omar", "Steinar", "Thomas", "Tina", "Tomas", "Vegard"];
        const METERS_PER_CLIMB = 14; // 4 floors * 3.5 meters per floor
        // --- END OF EDIT SECTION ---

        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyAuCviosEvMuvlq899_w_E2ldHD6v4epTI",
          authDomain: "stairclimbing-competition.firebaseapp.com",
          projectId: "stairclimbing-competition",
          storageBucket: "stairclimbing-competition.appspot.com",
          messagingSenderId: "408087478849",
          appId: "1:408087478849:web:cc4430940e9ee7f6c43cc0",
          measurementId: "G-3SC0FMDNCE"
        };
        const appId = 'stairclimbing-competition';
        const initialAuthToken = null;

        // --- App Initialization ---
        let app, db, auth, userId;

        // --- Date Helper ---
        function getWeekId(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return d.getUTCFullYear() + '-' + weekNo;
        }

        /**
         * Checks if a given date string (YYYY-MM-DD) is a weekday (Monday-Friday).
         * @param {string} dateString - The date string in 'YYYY-MM-DD' format.
         * @returns {boolean} True if the date is a weekday, false otherwise.
         */
        function isWeekday(dateString) {
            const date = new Date(dateString + 'T12:00:00Z'); // Use noon UTC to avoid timezone issues
            const day = date.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            return day >= 1 && day <= 5;
        }

        /**
         * Checks if two date strings represent consecutive weekdays, including weekend gaps.
         * @param {string} lastDateStr - The previous date string.
         * @param {string} newDateStr - The current date string.
         * @returns {boolean} True if consecutive, false otherwise.
         */
        function isConsecutiveDay(lastDateStr, newDateStr) {
            const lastDate = new Date(lastDateStr + 'T12:00:00Z');
            const newDate = new Date(newDateStr + 'T12:00:00Z');
            const diffInDays = (newDate - lastDate) / (1000 * 60 * 60 * 24);

            if (diffInDays === 1) {
                return isWeekday(newDateStr);
            } else if (lastDate.getUTCDay() === 5 && newDate.getUTCDay() === 1) { // Friday to Monday
                return true;
            }

            return false;
        }

        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) { console.error("Firebase initialization failed:", e); return; }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-info').textContent = `Your User ID: ${userId}`;
                    setupRealtimeListener();
                } else {
                    try {
                        if (initialAuthToken) { await signInWithCustomToken(auth, initialAuthToken); } 
                        else { await signInAnonymously(auth); }
                    } catch (error) { console.error("Anonymous sign-in failed:", error); }
                }
            });
        }
        
        // --- UI Rendering ---
        const participantCardsContainer = document.getElementById('participant-cards');

        function createParticipantCards() {
            participantCardsContainer.innerHTML = '';
            participants.forEach(name => {
                // Change the bg-white to bg-white bg-opacity-80
                const card = document.createElement('div');
                card.className = 'bg-white bg-opacity-80 p-4 rounded-2xl shadow-md flex flex-col items-center justify-center transition-transform hover:scale-105 relative';
                card.innerHTML = `
                    <!-- Streak icon, initially hidden -->
                    <div id="streak-${name}" class="streak-container hidden bg-red-500 text-white text-xs font-bold py-1 px-3 rounded-full">
                        <span class="mr-1">üî•</span><span id="streak-count-${name}">0</span>
                    </div>
                    <div class="text-xl font-semibold">${name}</div>
                    <!-- Made the score significantly larger here -->
                    <div class="text-6xl font-bold my-1 text-indigo-600" id="score-${name}">0</div>
                    <div class="text-sm font-semibold text-slate-600" id="ascent-${name}">0 m ascent</div>
                    <div class="text-xs text-slate-500 my-2 space-x-2">
                        <span>Week: <b id="weekly-score-${name}">0</b></span>
                        <span>Today: <b id="daily-score-${name}">0</b></span>
                    </div>
                    <button data-name="${name}" class="add-climb-btn bg-indigo-600 text-white font-bold py-2 px-6 rounded-full hover:bg-indigo-700 w-full">I Climbed!</button>
                    <button data-name="${name}" class="undo-climb-btn text-xs text-slate-400 hover:text-red-600 mt-2">Oops, undo last</button>
                `;
                participantCardsContainer.appendChild(card);
            });
        }
        
        function renderLeaderboard(containerId, scores, scoreType, showAscent) {
            const container = document.getElementById(containerId);
            const sortedScores = Object.values(scores).sort((a, b) => (b[scoreType] || 0) - (a[scoreType] || 0));
            container.innerHTML = '';

            if (sortedScores.filter(s => s[scoreType] > 0).length === 0) {
                container.innerHTML = `<div class="text-center text-slate-500">No climbs logged yet.</div>`;
                return;
            }

            sortedScores.forEach((player, index) => {
                const rank = index + 1;
                let medal = '';
                let podiumClass = '';
                if (rank === 1) { medal = 'ü•á'; podiumClass = 'podium-1'; }
                else if (rank === 2) { medal = 'ü•à'; podiumClass = 'podium-2'; }
                else if (rank === 3) { medal = 'ü•â'; podiumClass = 'podium-3'; }

                // Change the bg-white to bg-white bg-opacity-80
                const listItem = document.createElement('div');
                listItem.className = `flex items-center justify-between p-3 bg-white bg-opacity-80 rounded-lg border-2 border-transparent ${podiumClass}`;
                const score = player[scoreType] || 0;
                
                let subTextHtml = '';
                if (showAscent) {
                    const totalAscent = (score || 0) * METERS_PER_CLIMB;
                    subTextHtml = `<span class="text-xs text-slate-500 block">${totalAscent} m</span>`;
                }
                
                // Increased the size of the medal symbols and rank numbers
                const rankDisplay = (rank <= 3) ? `<span class="text-4xl">${medal}</span>` : `<span class="text-3xl font-bold">${rank}.</span>`;

                // Increased the font size of the name and score
                listItem.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <span class="text-center">${rankDisplay}</span>
                        <span class="text-2xl font-medium">${player.name}</span>
                    </div>
                    <div class="text-right">
                        <span class="text-2xl font-bold text-indigo-600">${score}</span>
                        ${subTextHtml}
                    </div>
                `;
                if (score > 0) container.appendChild(listItem);
            });
        }

        function updateUI(scores) {
            participants.forEach(name => {
                const data = scores[name] || {};
                const totalEl = document.getElementById(`score-${name}`);
                const weeklyEl = document.getElementById(`weekly-score-${name}`);
                const dailyEl = document.getElementById(`daily-score-${name}`);
                const ascentEl = document.getElementById(`ascent-${name}`);
                const streakEl = document.getElementById(`streak-${name}`);
                const streakCountEl = document.getElementById(`streak-count-${name}`);

                if (totalEl) totalEl.textContent = data.totalClimbs || 0;
                if (weeklyEl) weeklyEl.textContent = data.weeklyClimbs || 0;
                if (dailyEl) dailyEl.textContent = data.dailyClimbs || 0;
                if (ascentEl) {
                    const totalAscent = (data.totalClimbs || 0) * METERS_PER_CLIMB;
                    ascentEl.textContent = `${totalAscent} m ascent`;
                }

                // Show or hide the streak icon based on the streak count
                if (streakEl) {
                    if (data.streak && data.streak >= 1) {
                        streakEl.classList.remove('hidden');
                        streakCountEl.textContent = data.streak;
                    } else {
                        streakEl.classList.add('hidden');
                    }
                }
            });
            renderLeaderboard('leaderboard-list-overall', scores, 'totalClimbs', true);
            renderLeaderboard('leaderboard-list-weekly', scores, 'weeklyClimbs', true);
        }

        // --- Realtime Listener ---
        function setupRealtimeListener() {
            const collectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
            onSnapshot(collection(db, collectionPath), (snapshot) => {
                const scores = {};
                snapshot.docs.forEach(doc => { scores[doc.id] = doc.data(); });
                updateUI(scores);
            }, (error) => { console.error("Error fetching scores:", error); });
        }

        // --- Daily Summary ---
        async function createDailySummaryIfNeeded() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayId = yesterday.toISOString().slice(0, 10);

            const summaryCollectionPath = `/artifacts/${appId}/public/data/daily_summaries`;
            const summaryDocRef = doc(db, summaryCollectionPath, yesterdayId);

            const summaryDoc = await getDoc(summaryDocRef);
            if (!summaryDoc.exists()) {
                console.log(`Creating daily summary for ${yesterdayId}...`);
                const scoresCollectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
                const scoresSnapshot = await getDocs(collection(db, scoresCollectionPath));
                
                const summaryData = {
                    date: yesterdayId,
                    summaryTimestamp: serverTimestamp(),
                    participants: {}
                };

                scoresSnapshot.forEach(doc => {
                    const data = doc.data();
                    summaryData.participants[data.name] = {
                        totalClimbs: data.totalClimbs || 0,
                        climbsOnThisDay: data.lastResetDate === yesterdayId ? (data.dailyClimbs || 0) : 0
                    };
                });
                
                await setDoc(summaryDocRef, summaryData);
                console.log(`Daily summary for ${yesterdayId} created.`);
            }
        }

        // --- Participant Button Events ---
        participantCardsContainer.addEventListener('click', async (e) => {
            const button = e.target;
            const name = button.dataset.name;
            if (!name) return;

            const collectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
            const docRef = doc(db, collectionPath, name);

            // Add climb
            if (button.classList.contains('add-climb-btn')) {
                button.disabled = true;
                button.textContent = 'Logging...';
                try {
                    let isNewDay = false;
                    let totalAfterClimb = 0;

                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(docRef);
                        const now = new Date();
                        const todayId = now.toISOString().slice(0, 10);
                        const weekId = getWeekId(now);
                        let newStreak = 0;

                        if (!sfDoc.exists()) {
                            isNewDay = true;
                            totalAfterClimb = 1;
                            if (isWeekday(todayId)) newStreak = 1;
                            transaction.set(docRef, { name, totalClimbs: 1, dailyClimbs: 1, weeklyClimbs: 1, lastResetDate: todayId, lastWeeklyResetId: weekId, lastClimbDate: todayId, streak: newStreak, lastUpdated: serverTimestamp() });
                        } else {
                            const data = sfDoc.data();
                            const lastClimbDate = data.lastClimbDate || null;
                            if (data.lastResetDate !== todayId) isNewDay = true;

                            const newTotal = (data.totalClimbs || 0) + 1;
                            let newDaily = (data.dailyClimbs || 0) + 1;
                            let newWeekly = (data.weeklyClimbs || 0) + 1;
                            
                            // Streak logic
                            let currentStreak = data.streak || 0;
                            if (lastClimbDate === todayId) {
                                // Already climbed today, streak doesn't change
                                newStreak = currentStreak;
                            } else if (lastClimbDate && isConsecutiveDay(lastClimbDate, todayId)) {
                                // Consecutive day, increment streak
                                newStreak = currentStreak + 1;
                            } else if (isWeekday(todayId)) {
                                // First climb of the day and not consecutive, start a new streak
                                newStreak = 1;
                            } else {
                                // Not a weekday, streak is maintained but not incremented
                                newStreak = currentStreak;
                            }

                            if (isNewDay) newDaily = 1;
                            if (data.lastWeeklyResetId !== weekId) newWeekly = 1;
                            
                            totalAfterClimb = newTotal;
                            transaction.update(docRef, { totalClimbs: newTotal, dailyClimbs: newDaily, weeklyClimbs: newWeekly, lastResetDate: todayId, lastWeeklyResetId: weekId, lastClimbDate: todayId, streak: newStreak, lastUpdated: serverTimestamp() });
                        }
                    });

                    if (isNewDay) await createDailySummaryIfNeeded();

                    const climbsLogRef = collection(db, docRef.path, 'climbsLog');
                    await addDoc(climbsLogRef, { timestamp: serverTimestamp(), climberId: userId });

                    const auditLogCollectionPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                    const timestampId = new Date().toISOString();
                    const logDocId = `${userId}-${timestampId}`;
                    const logDocRef = doc(db, auditLogCollectionPath, logDocId);
                    await setDoc(logDocRef, {
                        participantName: name,
                        timestamp: serverTimestamp(),
                        date: timestampId.slice(0, 10),
                        climberId: userId,
                        action: "climb",
                        totalClimbsAfterAction: totalAfterClimb
                    });

                } catch (error) {
                    console.error("Add climb failed:", error);
                } finally {
                    setTimeout(() => {
                        button.disabled = false;
                        button.textContent = 'I Climbed!';
                    }, 500);
                }
            }

            // Undo climb
            if (button.classList.contains('undo-climb-btn')) {
                button.disabled = true;
                button.textContent = 'Undoing...';
                try {
                    let totalAfterUndo = 0;
                    const climbsLogRef = collection(db, docRef.path, 'climbsLog');
                    const q = query(climbsLogRef, orderBy('timestamp', 'desc'), limit(1));
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.empty) return;

                    await deleteDoc(querySnapshot.docs[0].ref);

                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(docRef);
                        if (!sfDoc.exists()) return;

                        const data = sfDoc.data();
                        const now = new Date();
                        const todayId = now.toISOString().slice(0, 10);
                        const weekId = getWeekId(now);

                        const newTotal = Math.max(0, (data.totalClimbs || 0) - 1);
                        let newDaily = data.lastResetDate === todayId ? Math.max(0, (data.dailyClimbs || 0) - 1) : (data.dailyClimbs || 0);
                        let newWeekly = data.lastWeeklyResetId === weekId ? Math.max(0, (data.weeklyClimbs || 0) - 1) : (data.weeklyClimbs || 0);
                        
                        totalAfterUndo = newTotal;
                        transaction.update(docRef, { totalClimbs: newTotal, dailyClimbs: newDaily, weeklyClimbs: newWeekly, lastUpdated: serverTimestamp() });
                    });

                    const auditLogCollectionPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                    const timestampId = new Date().toISOString();
                    const logDocId = `${userId}-${timestampId}`;
                    const logDocRef = doc(db, auditLogCollectionPath, logDocId);
                    await setDoc(logDocRef, {
                        participantName: name,
                        timestamp: serverTimestamp(),
                        date: timestampId.slice(0,10),
                        climberId: userId,
                        action: "undo",
                        totalClimbsAfterAction: totalAfterUndo
                    });
                } catch (error) {
                    console.error("Undo failed:", error);
                } finally {
                    setTimeout(() => {
                        button.disabled = false;
                        button.textContent = 'Oops, undo last';
                    }, 500);
                }
            }
        });

        // --- Reset Logic ---
        document.getElementById('reset-btn').addEventListener('click', async () => {
            const password = prompt("To reset all scores and logs, please enter the admin password:");
            const RESET_PASSWORD = "reset2025";

            if (password !== RESET_PASSWORD) {
                if (password !== null) alert("Incorrect password.");
                return;
            }

            if (!confirm("Are you absolutely sure you want to delete ALL data for this competition? This cannot be undone.")) {
                return;
            }

            const resetButton = document.getElementById('reset-btn');
            resetButton.disabled = true;
            resetButton.textContent = "Resetting...";

            try {
                const batch = writeBatch(db);
                const scoresPath = `/artifacts/${appId}/public/data/stairs_competition`;
                const scoresSnapshot = await getDocs(collection(db, scoresPath));
                scoresSnapshot.forEach(doc => batch.delete(doc.ref));

                const auditLogPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                const auditLogSnapshot = await getDocs(collection(db, auditLogPath));
                auditLogSnapshot.forEach(doc => batch.delete(doc.ref));

                const summaryPath = `/artifacts/${appId}/public/data/daily_summaries`;
                const summarySnapshot = await getDocs(collection(db, summaryPath));
                summarySnapshot.forEach(doc => batch.delete(doc.ref));
                
                await batch.commit();
                alert("Competition has been successfully reset.");
            } catch (error) {
                console.error("Reset failed:", error);
                alert("An error occurred during the reset process. Check the console for details.");
            } finally {
                resetButton.disabled = false;
                resetButton.textContent = "Reset Competition";
            }
        });

        // --- App Start ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
            createParticipantCards();
        });
    </script>
</body>
</html>

