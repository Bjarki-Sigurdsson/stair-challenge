<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Stair Climb Challenge! üßó‚Äç‚ôÄÔ∏è</title>
    <!-- Use the Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include Google Font 'Inter' for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /*
         * Main CSS for the background.
         * We apply these styles to the 'body' element to ensure the background covers the entire page.
         */
        body {
            font-family: 'Inter', sans-serif;
        }

        .mountain-bg {
            /* Set the background image to a high-quality mountain range. */
            background-image: url('https://images.unsplash.com/photo-1549880338-65ddcdfd017b?q=80&w=2938&auto=format&fit=crop&ixlib=rb-4.0.3');

            /*
             * background-size: 'cover' scales the image to be as large as possible
             * so that the background area is completely covered by the image.
             * Some parts of the image may not be in view.
             */
            background-size: cover;

            /*
             * background-position: 'center' centers the image horizontally and vertically.
             */
            background-position: center;

            /*
             * background-repeat: 'no-repeat' prevents the image from tiling (repeating).
             */
            background-repeat: no-repeat;

            /*
             * background-attachment: 'fixed' keeps the background image in the same
             * position relative to the viewport. This creates a cool parallax-like
             * effect when the user scrolls.
             */
            background-attachment: fixed;

            /*
             * Set the minimum height of the body to 100% of the viewport height.
             * This is important to ensure the background covers the entire screen,
             * even if the content is short.
             */
            min-height: 100vh;
        }
        
        /* Podium colors for the leaderboard. */
        .podium-1 { border-color: #FFD700; } /* Gold */
        .podium-2 { border-color: #C0C0C0; } /* Silver */
        .podium-3 { border-color: #CD7F32; } /* Bronze */

        /* CSS for the streak icon, making it an absolute position within the card */
        .streak-container {
            position: absolute;
            top: 1rem;
            left: 1rem;
        }

        /* Styling for the favorite button to be positioned in the corner */
        .favorite-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem; /* Larger star */
        }

        /* Styling for badges */
        .badge-icon {
            font-size: 1.5rem; /* Adjust size as needed */
            margin: 0 0.25rem;
            cursor: help; /* Indicate it's informational */
        }

        /* Styling for the badge reference list */
        .badge-reference-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: #4a5568; /* gray-700 for better readability on white background */
        }
        .badge-reference-item .icon {
            font-size: 1.2rem;
            margin-right: 0.5rem;
        }
    </style>
</head>
<body class="mountain-bg flex items-center justify-center p-4">

    <!-- Main outer container for the entire app content -->
    <div class="bg-black bg-opacity-10 p-4 md:p-8 rounded-2xl shadow-2xl max-w-screen-xl text-center backdrop-blur-sm w-full mx-auto my-auto relative z-10">

        <header class="text-center mb-8 relative">
            <!-- Increased heading size to make it more prominent -->
            <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold text-white">Stair Climb Challenge!</h1>
            <p class="text-gray-200 text-lg mt-2">Who will reach the summit before the Christmas party? üéÑ</p>
            <button id="reset-btn" class="absolute -top-5 -right-4 bg-red-500 text-white text-xs font-bold py-1 px-3 rounded-full hover:bg-red-600">Reset Competition</button>
        </header>

        <!-- Container for Leaderboards and Badge Reference, now in a single grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-8">
            <!-- Overall Leaderboard Section -->
            <section id="leaderboard-overall" class="bg-white p-3 rounded-2xl font-bold shadow-lg bg-opacity-80">
                <h2 class="text-3xl font-bold mb-4 text-center">Overall Leaderboard üèÜ</h2>
                <div id="leaderboard-list-overall" class="space-y-1">
                    <div class="text-center text-slate-500">Loading scores...</div>
                </div>
            </section>

            <!-- Weekly Leaderboard Section -->
            <section id="leaderboard-weekly" class="bg-white p-3 rounded-2xl font-bold shadow-lg bg-opacity-80">
                <h2 class="text-3xl font-bold mb-4 text-center">This Week's Leaders üóìÔ∏è</h2>
                <div id="leaderboard-list-weekly" class="space-y-1">
                    <div class="text-center text-slate-500">Loading scores...</div>
                </div>
            </section>

            <!-- Mountain Badges List -->
            <section id="badge-reference-section" class="bg-white p-3 rounded-2xl font-bold shadow-lg bg-opacity-80">
                <h3 class="text-xl font-bold text-gray-800 mb-2">Mountain Badges üèÜ</h3>
                <div id="badge-reference-list" class="flex flex-wrap justify-center lg:flex-col lg:items-start gap-x-4 gap-y-1">
                    <!-- Badge reference items will be injected here by JavaScript -->
                    <div class="text-gray-700">Loading badges...</div>
                </div>
            </section>
        </div>

        <!-- Participants Section -->
        <section id="participants" class="mt-8">
            <h2 class="text-2xl font-bold mb-4 text-center text-white">Log Your Climb üëü</h2>
            <div id="participant-cards" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Participant cards will be injected here by JavaScript -->
            </div>
        </section>
        
        <!-- User ID display -->
        <div id="user-info" class="text-center mt-8 text-xs text-slate-400"></div>
    </div>
    
    <!-- Custom Modal/Dialog for alerts and confirmations -->
    <div id="modal-container" class="fixed inset-0 z-50 hidden flex items-center justify-center bg-black bg-opacity-50">
        <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm w-full mx-4">
            <p id="modal-text" class="text-lg font-medium mb-4"></p>
            <div id="modal-actions" class="flex justify-center space-x-4">
                <button id="modal-confirm-btn" class="bg-red-500 text-white font-bold py-2 px-6 rounded-full hover:bg-red-600">Confirm</button>
                <button id="modal-cancel-btn" class="bg-gray-300 text-gray-800 font-bold py-2 px-6 rounded-full hover:bg-gray-400">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Firebase and App Logic -->
    <script type="module">
        // IMPORTANT: Firebase imports. Do not change these.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, runTransaction, setDoc, serverTimestamp, addDoc, query, orderBy, limit, getDocs, getDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- ‚úèÔ∏è EDIT THIS SECTION ---
        // Add the names of all participants here.
        const participants = ["Anders L", "Anders S", "Annett", "Bjarki", "Eivind", "Erik √ò", "Erik T", "Felipe", "Flora", "Fredrik A", "Fredrik D", "Frode H", "Frode V", "Halvard", "Henok", "Kristin", "Lars", "Lene", "Love", "Magnus", "M√•ns", "Marcin", "Marcus", "Maria", "Martin", "Michal", "Morten", "Mostafa", "Niklas", "Omar", "Steinar", "Thomas", "Tina", "Tomas", "Vegard"];
        const METERS_PER_CLIMB = 14; // 4 floors * 3.5 meters per floor

        // Define your mountain badges here with unique icons
        const mountainBadges = [
            { name: "Galdh√∏piggen", heightMeters: 2469, icon: "üêë" }, // Sheep for Galdh√∏piggen
            { name: "Mount Fuji", heightMeters: 3776, icon: "üóª" }, 
            { name: "Mount Rainier", heightMeters: 4392, icon: "üåã" }, 
            { name: "Mont Blanc", heightMeters: 4808, icon: "üêê" }, // Goat for Mont Blanc
            { name: "Everest Base Camp", heightMeters: 5364, icon: "üèïÔ∏è" },
            { name: "Mount Kilimanjaro", heightMeters: 5895, icon: "üåç" }, 
            { name: "Mount Everest Summit", heightMeters: 8848, icon: "üîù" } 
        ].sort((a, b) => a.heightMeters - b.heightMeters); // Sort by height for easier checking
        // --- END OF EDIT SECTION ---

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAuCviosEvMuvlq899_w_E2ldHD6v4epTI",
            authDomain: "stairclimbing-competition.firebaseapp.com",
            projectId: "stairclimbing-competition",
            storageBucket: "stairclimbing-competition.appspot.com",
            messagingSenderId: "408087478849",
            appId: "1:408087478849:web:cc4430940e9ee7f6c43cc0",
            measurementId: "G-3SC0FMDNCE"
        };
        const appId = 'stairclimbing-competition';
        const initialAuthToken = null;

        // --- App Initialization ---
        let app, db, auth, userId;
        let isAuthReady = false;
        let favoriteParticipant = null;
        let currentScores = {}; // Global variable to store the latest scores

        // --- Date Helper ---
        /**
         * Calculates the week number for a given date.
         * @param {Date} d - The date object.
         * @returns {string} The year and week number in 'YYYY-WW' format.
         */
        function getWeekId(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return d.getUTCFullYear() + '-' + weekNo;
        }

        /**
         * Checks if a given date string (YYYY-MM-DD) is a weekday (Monday-Friday).
         * @param {string} dateString - The date string in 'YYYY-MM-DD' format.
         * @returns {boolean} True if the date is a weekday, false otherwise.
         */
        function isWeekday(dateString) {
            const date = new Date(dateString + 'T12:00:00Z'); // Use noon UTC to avoid timezone issues
            const day = date.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            return day >= 1 && day <= 5;
        }

        /**
         * Checks if two date strings represent consecutive weekdays, including weekend gaps.
         * @param {string} lastDateStr - The previous date string.
         * @param {string} newDateStr - The current date string.
         * @returns {boolean} True if consecutive, false otherwise.
         */
        function isConsecutiveDay(lastDateStr, newDateStr) {
            const lastDate = new Date(lastDateStr + 'T12:00:00Z');
            const newDate = new Date(newDateStr + 'T12:00:00Z');
            const diffInDays = (newDate - lastDate) / (1000 * 60 * 60 * 24);

            if (diffInDays === 1) {
                return isWeekday(newDateStr);
            } else if (lastDate.getUTCDay() === 5 && newDate.getUTCDay() === 1 && diffInDays <= 3) { // Friday to Monday
                return true;
            }

            return false;
        }

        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                return;
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    isAuthReady = true;
                    document.getElementById('user-info').textContent = `Your User ID: ${userId}`;
                    setupRealtimeListener();
                    setupFavoritesListener(); 
                    renderBadgeReference(); // Render badge reference once Firebase is initialized
                } else {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Anonymous sign-in failed:", error);
                    }
                }
            });
        }
        
        // --- UI Rendering ---
        const participantCardsContainer = document.getElementById('participant-cards');
        const badgeReferenceList = document.getElementById('badge-reference-list');

        /**
         * Dynamically creates the participant cards on the page.
         * @param {string | null} favoriteName - The name of the favorited participant.
         */
        function createParticipantCards(favoriteName) {
            participantCardsContainer.innerHTML = '';
            
            // Reorder participants with the favorite at the top
            const sortedParticipants = [];
            const otherParticipants = [];
            participants.forEach(name => {
                if (name === favoriteName) {
                    sortedParticipants.unshift(name);
                } else {
                    otherParticipants.push(name);
                }
            });
            sortedParticipants.push(...otherParticipants);

            sortedParticipants.forEach(name => {
                const isFavorite = name === favoriteName;
                const card = document.createElement('div');
                card.className = 'bg-white bg-opacity-80 p-4 rounded-2xl shadow-md flex flex-col items-center justify-center transition-transform hover:scale-105 relative';
                
                // Get participant's total ascent to display badges
                const totalAscent = (currentScores[name]?.totalClimbs || 0) * METERS_PER_CLIMB;
                let badgesHtml = '';
                mountainBadges.forEach(badge => {
                    if (totalAscent >= badge.heightMeters) {
                        badgesHtml += `<span class="badge-icon" title="${badge.name} (${badge.heightMeters}m)">${badge.icon}</span>`;
                    }
                });

                card.innerHTML = `
                    <!-- Streak icon, initially hidden -->
                    <div id="streak-${name}" class="streak-container hidden bg-red-500 text-white text-xs font-bold py-1 px-3 rounded-full">
                        <span class="mr-1">üî•</span><span id="streak-count-${name}">0</span>
                    </div>
                    <!-- Favorite star icon -->
                    <div data-name="${name}" class="favorite-btn ${isFavorite ? 'text-white' : 'text-gray-300 opacity-50'} hover:text-white transition-colors">
                        ‚≠ê
                    </div>
                    <!-- Increased the font size of the name to be larger -->
                    <div class="text-2xl font-semibold">${name}</div>
                    <!-- Made the score significantly larger here -->
                    <div class="text-4xl font-bold my-1 text-indigo-600" id="score-${name}">0</div>
                    <div class="text-sm font-semibold text-slate-600" id="ascent-${name}">0 m ascent</div>
                    <div class="text-xs text-slate-500 my-2 space-x-2">
                        <span>Week: <b id="weekly-score-${name}">0</b></span>
                        <span>Today: <b id="daily-score-${name}">0</b></span>
                    </div>
                    <div id="badges-${name}" class="flex justify-center mt-2 h-8 items-center">
                        ${badgesHtml}
                    </div>
                    <button data-name="${name}" class="add-climb-btn bg-indigo-600 text-white font-bold py-2 px-6 rounded-full hover:bg-indigo-700 w-full">I Climbed!</button>
                    <button data-name="${name}" class="undo-climb-btn text-xs text-slate-400 hover:text-red-600 mt-2">Oops, undo last</button>
                `;
                participantCardsContainer.appendChild(card);
            });
        }

        /**
         * Renders the list of available mountain badges at the top of the page.
         */
        function renderBadgeReference() {
            if (!badgeReferenceList) return;
            let referenceHtml = '';
            mountainBadges.forEach(badge => {
                referenceHtml += `
                    <div class="badge-reference-item" title="${badge.name} (${badge.heightMeters}m)">
                        <span class="icon">${badge.icon}</span> 
                        <span>${badge.name} (${badge.heightMeters}m)</span>
                    </div>
                `;
            });
            badgeReferenceList.innerHTML = referenceHtml;
        }
        
        /**
         * Renders the leaderboard in the specified container.
         * @param {string} containerId - The ID of the container element.
         * @param {object} scores - The scores data.
         * @param {string} scoreType - The score field to display (e.g., 'totalClimbs').
         * @param {boolean} showAscent - Whether to display the total meters climbed.
         */
        function renderLeaderboard(containerId, scores, scoreType, showAscent) {
            const container = document.getElementById(containerId);
            const sortedScores = Object.values(scores).sort((a, b) => (b[scoreType] || 0) - (a[scoreType] || 0));
            container.innerHTML = '';

            if (sortedScores.filter(s => s[scoreType] > 0).length === 0) {
                container.innerHTML = `<div class="text-center text-slate-500">No climbs logged yet.</div>`;
                return;
            }

            // Limit to top 3 entries
            const top3Scores = sortedScores.slice(0, 3);

            top3Scores.forEach((player, index) => {
                const rank = index + 1;
                let medal = '';
                let podiumClass = '';
                if (rank === 1) { medal = 'ü•á'; podiumClass = 'podium-1'; }
                else if (rank === 2) { medal = 'ü•à'; podiumClass = 'podium-2'; }
                else if (rank === 3) { medal = 'ü•â'; podiumClass = 'podium-3'; }

                const listItem = document.createElement('div');
                listItem.className = `flex items-center justify-between p-3 bg-white bg-opacity-80 rounded-lg border-2 border-transparent ${podiumClass}`;
                const score = player[scoreType] || 0;
                
                let subTextHtml = '';
                if (showAscent) {
                    const totalAscent = (score || 0) * METERS_PER_CLIMB;
                    subTextHtml = `<span class="text-xs text-slate-500 block">${totalAscent} m</span>`;
                }
                
                // Increased the size of the medal symbols and rank numbers
                const rankDisplay = (rank <= 3) ? `<span class="text-3xl">${medal}</span>` : `<span class="text-3xl font-bold">${rank}.</span>`;

                // Increased the font size of the name and score
                listItem.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <span class="text-center">${rankDisplay}</span>
                        <span class="text-2xl font-medium">${player.name}</span>
                    </div>
                    <div class="text-right">
                        <span class="text-2xl font-bold text-indigo-600">${score}</span>
                        ${subTextHtml}
                    </div>
                `;
                if (score > 0) container.appendChild(listItem);
            });
        }

        /**
         * Updates the UI elements for a single participant.
         * @param {object} scores - The full scores object from Firestore.
         */
        function updateUI(scores) {
            participants.forEach(name => {
                const data = scores[name] || {};
                const totalEl = document.getElementById(`score-${name}`);
                const weeklyEl = document.getElementById(`weekly-score-${name}`);
                const dailyEl = document.getElementById(`daily-score-${name}`);
                const ascentEl = document.getElementById(`ascent-${name}`);
                const streakEl = document.getElementById(`streak-${name}`);
                const streakCountEl = document.getElementById(`streak-count-${name}`);
                const badgesContainer = document.getElementById(`badges-${name}`);

                if (totalEl) totalEl.textContent = data.totalClimbs || 0;
                if (weeklyEl) weeklyEl.textContent = data.weeklyClimbs || 0;
                if (dailyEl) dailyEl.textContent = data.dailyClimbs || 0;
                if (ascentEl) {
                    const totalAscent = (data.totalClimbs || 0) * METERS_PER_CLIMB;
                    ascentEl.textContent = `${totalAscent} m ascent`;
                }

                // Show or hide the streak icon based on the streak count
                if (streakEl) {
                    if (data.streak && data.streak > 1) { // Only show for streaks > 1
                        streakEl.classList.remove('hidden');
                        streakCountEl.textContent = data.streak;
                    } else {
                        streakEl.classList.add('hidden');
                    }
                }

                // Update badges display
                if (badgesContainer) {
                    const totalAscent = (data.totalClimbs || 0) * METERS_PER_CLIMB;
                    let badgesHtml = '';
                    mountainBadges.forEach(badge => {
                        if (totalAscent >= badge.heightMeters) {
                            badgesHtml += `<span class="badge-icon" title="${badge.name} (${badge.heightMeters}m)">${badge.icon}</span>`;
                        }
                    });
                    badgesContainer.innerHTML = badgesHtml;
                }
            });
            renderLeaderboard('leaderboard-list-overall', scores, 'totalClimbs', true);
            renderLeaderboard('leaderboard-list-weekly', scores, 'totalClimbs', true);
        }

        // --- Realtime Listeners ---
        /**
         * Sets up the Firestore listener to get real-time score updates.
         */
        function setupRealtimeListener() {
            if (!db || !isAuthReady) return;
            const collectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
            onSnapshot(collection(db, collectionPath), (snapshot) => {
                currentScores = {}; // Update global scores
                snapshot.docs.forEach(doc => { currentScores[doc.id] = doc.data(); });
                updateUI(currentScores); // Now updateUI always uses the latest scores
            }, (error) => {
                console.error("Error fetching scores:", error);
            });
        }

        /**
         * Sets up a Firestore listener for the user's favorite participant.
         */
        function setupFavoritesListener() {
            if (!db || !userId) return;
            const docRef = doc(db, `/artifacts/${appId}/users/${userId}/preferences`, 'favorites');
            onSnapshot(docRef, (doc) => {
                if (doc.exists() && doc.data().name) {
                    favoriteParticipant = doc.data().name;
                } else {
                    favoriteParticipant = null;
                }
                // Call createParticipantCards here AFTER favoriteParticipant is known
                createParticipantCards(favoriteParticipant);
                // Also call updateUI here to populate scores immediately after cards are re-created/re-ordered
                updateUI(currentScores); 
            }, (error) => {
                console.error("Error fetching user preferences:", error);
            });
        }

        // --- Daily Summary ---
        async function createDailySummaryIfNeeded() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayId = yesterday.toISOString().slice(0, 10);

            const summaryCollectionPath = `/artifacts/${appId}/public/data/daily_summaries`;
            const summaryDocRef = doc(db, summaryCollectionPath, yesterdayId);

            try {
                const summaryDoc = await getDoc(summaryDocRef);
                if (!summaryDoc.exists() && isWeekday(yesterdayId)) {
                    console.log(`Creating daily summary for ${yesterdayId}...`);
                    const scoresCollectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
                    const scoresSnapshot = await getDocs(collection(db, scoresCollectionPath));
                    
                    const summaryData = {
                        date: yesterdayId,
                        summaryTimestamp: serverTimestamp(),
                        participants: {}
                    };

                    scoresSnapshot.forEach(doc => {
                        const data = doc.data();
                        summaryData.participants[data.name] = {
                            totalClimbs: data.totalClimbs || 0,
                            climbsOnThisDay: data.lastClimbDate === yesterdayId ? (data.dailyClimbs || 0) : 0
                        };
                    });
                    
                    await setDoc(summaryDocRef, summaryData);
                    console.log(`Daily summary for ${yesterdayId} created.`);
                }
            } catch (error) {
                console.error("Failed to create daily summary:", error);
            }
        }

        // --- Participant Button Events ---
        participantCardsContainer.addEventListener('click', async (e) => {
            const button = e.target;
            const name = button.dataset.name;
            if (!name) { 
                console.log("No name found for clicked element.");
                return;
            }

            // Ensure Firebase is ready before proceeding with any DB operations
            if (!isAuthReady || !db || !userId) {
                console.warn("Firebase not ready. Auth state:", isAuthReady, "DB:", db, "UserID:", userId);
                showMessage("The app is still loading. Please wait a moment and try again.");
                return;
            }

            // Handle favorite button click
            if (button.classList.contains('favorite-btn')) {
                const favoriteDocRef = doc(db, `/artifacts/${appId}/users/${userId}/preferences`, 'favorites');
                
                try {
                    if (favoriteParticipant === name) {
                        console.log(`Unfavoriting ${name} for user ${userId}`);
                        await deleteDoc(favoriteDocRef);
                    } else {
                        console.log(`Favoriting ${name} for user ${userId}`);
                        await setDoc(favoriteDocRef, { name });
                    }
                } catch (error) {
                    console.error("Failed to update favorite:", error);
                    showMessage("Failed to update favorite. Please try again.");
                }
                return; 
            }

            // Handle add/undo climb buttons
            const collectionPath = `/artifacts/${appId}/public/data/stairs_competition`;
            const docRef = doc(db, collectionPath, name);

            // Add climb
            if (button.classList.contains('add-climb-btn')) {
                button.disabled = true;
                button.textContent = 'Logging...';
                try {
                    let totalAfterClimb = 0;
                    
                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(docRef);
                        const now = new Date();
                        const todayId = now.toISOString().slice(0, 10);
                        const weekId = getWeekId(now);
                        
                        let data = {};
                        if (sfDoc.exists()) {
                            data = sfDoc.data();
                        } else {
                            data = {
                                name,
                                totalClimbs: 0,
                                dailyClimbs: 0,
                                weeklyClimbs: 0,
                                lastResetDate: todayId,
                                lastWeeklyResetId: weekId,
                                lastClimbDate: todayId,
                                streak: 0,
                                lastUpdated: serverTimestamp(),
                                lastClimbLogId: null
                            };
                        }

                        // Check for new day/week and reset scores
                        if (data.lastResetDate !== todayId) {
                            data.dailyClimbs = 0;
                            data.lastResetDate = todayId;
                            // Reset streak if not consecutive day
                            if (data.lastClimbDate && !isConsecutiveDay(data.lastClimbDate, todayId)) {
                                data.streak = 0;
                            }
                        }
                        if (data.lastWeeklyResetId !== weekId) {
                            data.weeklyClimbs = 0;
                            data.lastWeeklyResetId = weekId;
                        }

                        // Check and update streak
                        if (data.lastClimbDate !== todayId && isWeekday(todayId)) {
                            if (data.lastClimbDate && isConsecutiveDay(data.lastClimbDate, todayId)) {
                                data.streak = (data.streak || 0) + 1;
                            } else {
                                data.streak = 1;
                            }
                        }

                        // Update all scores for the transaction
                        data.totalClimbs = (data.totalClimbs || 0) + 1;
                        data.dailyClimbs = (data.dailyClimbs || 0) + 1;
                        data.weeklyClimbs = (data.weeklyClimbs || 0) + 1;
                        data.lastClimbDate = todayId;
                        data.lastUpdated = serverTimestamp();
                        totalAfterClimb = data.totalClimbs;

                        transaction.set(docRef, data);
                    });

                    // Log the climb as a separate document and link it
                    const climbsLogRef = collection(db, docRef.path, 'climbsLog');
                    const newLogDocRef = doc(climbsLogRef); // Create a document reference with an auto-generated ID
                    await setDoc(newLogDocRef, { timestamp: serverTimestamp(), climberId: userId });

                    // Log to a public audit log
                    const auditLogCollectionPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                    await addDoc(collection(db, auditLogCollectionPath), {
                        participantName: name,
                        timestamp: serverTimestamp(),
                        date: new Date().toISOString().slice(0, 10),
                        climberId: userId,
                        action: "climb",
                        totalClimbsAfterAction: totalAfterClimb
                    });

                } catch (error) {
                    console.error("Add climb failed:", error);
                } finally {
                    setTimeout(() => {
                        button.disabled = false;
                        button.textContent = 'I Climbed!';
                    }, 500);
                }
            }

            // Undo climb
            if (button.classList.contains('undo-climb-btn')) {
                button.disabled = true;
                button.textContent = 'Undoing...';
                try {
                    const climbsLogRef = collection(db, docRef.path, 'climbsLog');
                    const allClimbs = await getDocs(climbsLogRef);

                    // Find the last climb log by sorting in memory
                    const sortedClimbs = allClimbs.docs.map(d => ({id: d.id, data: d.data()}))
                        .sort((a, b) => b.data.timestamp.toDate() - a.data.timestamp.toDate());
                    
                    if (sortedClimbs.length === 0) {
                        console.log("No climbs to undo.");
                        return;
                    }
                    const lastClimbDocRef = doc(climbsLogRef, sortedClimbs[0].id);

                    // Start transaction to update main document and then delete log
                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(docRef);
                        if (!sfDoc.exists()) return;

                        const data = sfDoc.data();
                        const newTotal = Math.max(0, (data.totalClimbs || 0) - 1);
                        const newWeekly = Math.max(0, (data.weeklyClimbs || 0) - 1);
                        const newDaily = Math.max(0, (data.dailyClimbs || 0) - 1);
                        
                        // Recalculate streak after undoing the last climb
                        const todayId = new Date().toISOString().slice(0, 10);
                        let newStreak = 0;
                        if (sortedClimbs.length > 1) {
                            const secondLastDateStr = sortedClimbs[1].data.timestamp.toDate().toISOString().slice(0, 10);
                            if (isConsecutiveDay(secondLastDateStr, todayId)) {
                                // If the day before the undone climb was a consecutive day, the streak continues
                                newStreak = data.streak || 0;
                            } else {
                                // The streak is broken, reset to 1 if today's climb is the new streak starter.
                                newStreak = (isWeekday(todayId) && newDaily > 0) ? 1 : 0;
                            }
                        } else {
                            // Only one climb, so streak becomes 0 after undo
                            newStreak = 0;
                        }

                        // Update the participant's main document
                        transaction.update(docRef, { 
                            totalClimbs: newTotal, 
                            dailyClimbs: newDaily, 
                            weeklyClimbs: newWeekly, 
                            streak: newStreak,
                            lastUpdated: serverTimestamp() 
                        });
                        
                        transaction.delete(lastClimbDocRef);
                    });

                    // Log to a public audit log
                    const auditLogCollectionPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                    await addDoc(collection(db, auditLogCollectionPath), {
                        participantName: name,
                        timestamp: serverTimestamp(),
                        date: new Date().toISOString().slice(0, 10),
                        climberId: userId,
                        action: "undo",
                        totalClimbsAfterAction: Math.max(0, (currentScores[name]?.totalClimbs || 0) - 1)
                    });

                } catch (error) {
                    console.error("Undo failed:", error);
                } finally {
                    setTimeout(() => {
                        button.disabled = false;
                        button.textContent = 'Oops, undo last';
                    }, 500);
                }
            }
        });
        
        // --- Modal Functions ---
        const modalContainer = document.getElementById('modal-container');
        const modalText = document.getElementById('modal-text');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        /**
         * Shows a modal with a message and a single 'OK' button.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            modalText.textContent = message;
            modalConfirmBtn.textContent = 'OK';
            modalConfirmBtn.onclick = hideModal;
            modalCancelBtn.classList.add('hidden');
            modalContainer.classList.remove('hidden');
        }

        /**
         * Shows a modal with a message and 'Confirm' and 'Cancel' buttons.
         * @param {string} message - The message to display.
         * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false if canceled.
         */
        function showConfirmation(message) {
            return new Promise(resolve => {
                modalText.textContent = message;
                modalConfirmBtn.textContent = 'Yes, I\'m sure';
                modalCancelBtn.textContent = 'Cancel';
                modalCancelBtn.classList.remove('hidden');
                
                modalConfirmBtn.onclick = () => {
                    hideModal();
                    resolve(true);
                };
                modalCancelBtn.onclick = () => {
                    hideModal();
                    resolve(false);
                };
                
                modalContainer.classList.remove('hidden');
            });
        }

        /**
         * Hides the modal window.
         */
        function hideModal() {
            modalContainer.classList.add('hidden');
        }

        // --- Reset Logic ---
        document.getElementById('reset-btn').addEventListener('click', async () => {
            const password = prompt("To reset all scores and logs, please enter the admin password:");
            const RESET_PASSWORD = "reset2025"; 

            if (password !== RESET_PASSWORD) {
                if (password !== null) showMessage("Incorrect password. Reset aborted.");
                return;
            }

            const confirmed = await showConfirmation("Are you absolutely sure you want to delete ALL data for this competition? This cannot be undone.");
            if (!confirmed) return;

            const resetButton = document.getElementById('reset-btn');
            resetButton.disabled = true;
            resetButton.textContent = "Resetting...";

            try {
                const batch = writeBatch(db);
                const scoresPath = `/artifacts/${appId}/public/data/stairs_competition`;
                const scoresSnapshot = await getDocs(collection(db, scoresPath));
                scoresSnapshot.forEach(doc => batch.delete(doc.ref));

                const auditLogPath = `/artifacts/${appId}/public/data/stairs_competition_log`;
                const auditLogSnapshot = await getDocs(collection(db, auditLogPath));
                auditLogSnapshot.forEach(doc => batch.delete(doc.ref));

                const summaryPath = `/artifacts/${appId}/public/data/daily_summaries`;
                const summarySnapshot = await getDocs(collection(db, summaryPath));
                summarySnapshot.forEach(doc => batch.delete(doc.ref));
                
                await batch.commit();
                showMessage("Competition has been successfully reset.");
            } catch (error) {
                console.error("Reset failed:", error);
                showMessage("An error occurred during the reset process. Check the console for details.");
            } finally {
                resetButton.disabled = false;
                resetButton.textContent = "Reset Competition";
            }
        });

        // --- App Start ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
        });
    </script>
</body>
</html>
